#!/usr/bin/env bash
# clean-repo - remove files ignored by git (safe defaults)
# Version: 1.2.0

set -euo pipefail

SCRIPT_NAME="$(basename "$0")"
VERSION="1.2.0"

DRY_RUN=true
VERBOSE=false
QUIET=false
EXCLUDE_PATTERNS=()

# small color helpers
if [[ -t 2 ]] && command -v tput >/dev/null 2>&1; then
  RED=$(tput setaf 1); GREEN=$(tput setaf 2); YELLOW=$(tput setaf 3)
  BLUE=$(tput setaf 4); CYAN=$(tput setaf 6); BOLD=$(tput bold); RESET=$(tput sgr0)
else
  RED=""; GREEN=""; YELLOW=""; BLUE=""; CYAN=""; BOLD=""; RESET=""
fi

log_info()  { [[ "$QUIET" == true ]] && return 0; printf "%bℹ%b %s\n" "$BLUE" "$RESET" "$*" >&2; }
log_ok()    { [[ "$QUIET" == true ]] && return 0; printf "%b✓%b %s\n" "$GREEN" "$RESET" "$*" >&2; }
log_warn()  { [[ "$QUIET" == true ]] && return 0; printf "%b⚠%b %s\n" "$YELLOW" "$RESET" "$*" >&2; }
log_err()   { printf "%b✗%b %s\n" "$RED" "$RESET" "$*" >&2; }
log_debug() { [[ "$VERBOSE" == true ]] || return 0; printf "%bDEBUG:%b %s\n" "$CYAN" "$RESET" "$*" >&2; }

EXIT_SUCCESS=0
EXIT_INVALID_ARGS=1
EXIT_NO_GITIGNORE=2
EXIT_NOT_GIT_REPO=3
EXIT_OPERATION_FAILED=4

usage() {
  cat <<EOF
  
${BOLD}Usage:${RESET} ${SCRIPT_NAME} [-x] [-i PATTERN]... [-v] [-q]

${BOLD}Options:${RESET}
  -x            Execute deletion (default: dry-run)
  -i PATTERN    Exclude pattern (repeatable)
  -v            Verbose
  -q            Quiet
  -h, --help    Show help
  --version     Show version

${BOLD}Examples:${RESET}
  ${SCRIPT_NAME}                              # Show what would be deleted
  ${SCRIPT_NAME} -x                           # Delete ignored files
  ${SCRIPT_NAME} -i "*.log" -x                # Delete, but keep logs

For detailed documentation, see: man ${SCRIPT_NAME}
EOF
}

ensure_git_root() {
  if ! command -v git >/dev/null 2>&1; then
    log_err "git is required but not found"
    exit $EXIT_OPERATION_FAILED
  fi

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    log_err "Not inside a git repository"
    exit $EXIT_NOT_GIT_REPO
  fi

  repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" || {
    log_err "Failed to determine git repository root"
    exit $EXIT_NOT_GIT_REPO
  }
  cd "$repo_root"
  log_debug "Changed to repository root: $repo_root"

  if [[ ! -f .gitignore ]]; then
    log_err ".gitignore not found in repository root ($repo_root)"
    exit $EXIT_NO_GITIGNORE
  fi

  if [[ ! -r .gitignore ]]; then
    log_err ".gitignore is not readable"
    exit $EXIT_OPERATION_FAILED
  fi
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -x) DRY_RUN=false; shift ;;
      -v) VERBOSE=true; shift ;;
      -q) QUIET=true; shift ;;
      -i)
        if [[ -z "${2:-}" || "$2" == -* ]]; then
          log_err "-i requires a pattern argument"
          usage; exit $EXIT_INVALID_ARGS
        fi
        EXCLUDE_PATTERNS+=("$2"); shift 2
        ;;
      --version) printf "%s %s\n" "$SCRIPT_NAME" "$VERSION"; exit $EXIT_SUCCESS ;;
      -h|--help) usage; exit $EXIT_SUCCESS ;;
      -*)
        log_err "Unknown option: $1"; usage; exit $EXIT_INVALID_ARGS ;;
      *) log_err "Unexpected argument: $1"; usage; exit $EXIT_INVALID_ARGS ;;
    esac
  done
}

matches_exclude() {
  local file="$1"
  for pat in "${EXCLUDE_PATTERNS[@]}"; do
    case "$file" in
      $pat) return 0 ;;
    esac
  done
  return 1
}

collect_ignored_files() {
  # Use NUL-separated output to handle arbitrary filenames.
  # -o (--others) required when using -i (--ignored)
  # --exclude-standard honors .gitignore, .git/info/exclude, and global excludes.
  mapfile -t -d '' IGNORED_FILES < <(git ls-files -oi --exclude-standard --directory -z 2>/dev/null || true)
}

perform_cleanup() {
  collect_ignored_files
  local total=${#IGNORED_FILES[@]}
  log_debug "Ignored files found: $total"

  if [[ $total -eq 0 ]]; then
    log_ok "No ignored files found — repository is clean."
    return $EXIT_SUCCESS
  fi

  files_to_delete=()
  excluded_list=()

  for f in "${IGNORED_FILES[@]}"; do
    # trim trailing slash which git ls-files may include for directories with --directory
    f="${f%/}"
    [[ -z "$f" ]] && continue
    if matches_exclude "$f"; then
      excluded_list+=("$f")
      log_debug "Excluded by pattern: $f"
    else
      files_to_delete+=("$f")
    fi
  done

  if [[ ${#files_to_delete[@]} -eq 0 ]]; then
    log_ok "No (non-excluded) ignored files to delete."
    [[ ${#excluded_list[@]} -gt 0 ]] && log_info "Excluded ${#excluded_list[@]} files."
    return $EXIT_SUCCESS
  fi

  if [[ "$DRY_RUN" == true ]]; then
    log_info "DRY RUN — the following files/dirs would be removed:"
    for p in "${files_to_delete[@]}"; do printf "  %s\n" "$p"; done
    if [[ ${#excluded_list[@]} -gt 0 ]]; then
      log_info "Excluded (${#excluded_list[@]}):"
      for p in "${excluded_list[@]}"; do printf "  %s\n" "$p"; done
    fi
    log_warn "Run with -x to actually delete the listed files."
    return $EXIT_SUCCESS
  fi

  # Execute deletion
  local failures=0
  for p in "${files_to_delete[@]}"; do
    if rm -rf -- "$p"; then
      log_debug "Deleted: $p"
    else
      log_err "Failed to delete: $p"
      ((failures++))
    fi
  done

  if [[ $failures -gt 0 ]]; then
    log_warn "Deletion completed with $failures failure(s)."
    return $EXIT_OPERATION_FAILED
  fi

  log_ok "Successfully deleted ${#files_to_delete[@]} item(s)."
  return $EXIT_SUCCESS
}

main() {
  parse_args "$@"
  ensure_git_root
  perform_cleanup
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
